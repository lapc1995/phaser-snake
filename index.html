<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
</head>
<body>

    <script>
    const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 200 }
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        },
    };

    const game = new Phaser.Game(config);

    const tileSize = 25;

    let snakeHead;
    const snakeBody = [];
    let apple;

    let elapsedTime = 0.0;
    let direction = 'r';

    let growSnake = false;

    function preload () { }

    function create () {
        gameStart(this);
    }

    function update (time, delta) {

        const cursors = this.input.keyboard.createCursorKeys();
        if (cursors.left.isDown && direction != 'r' && direction != 'l')
            direction = 'l';
        else if (cursors.right.isDown && direction != 'r' && direction != 'l')
            direction = 'r';
        else if (cursors.up.isDown && direction != 'u' && direction != 'd')
            direction = 'u';
        else if (cursors.down.isDown && direction != 'u' && direction != 'd')
            direction = 'd';

        elapsedTime += delta;

        if(elapsedTime > 50) {

            let prevX = snakeHead.rect.x; 
            let prevY = snakeHead.rect.y;

            const boundsCheck = {
                'r' : () => snakeHead.rect.x = snakeHead.rect.x > 800 - (tileSize * 2) ? 0 : snakeHead.rect.x + tileSize,
                'l' : () => snakeHead.rect.x = snakeHead.rect.x < tileSize ? 800 - tileSize : snakeHead.rect.x - tileSize,
                'u' : () => snakeHead.rect.y = snakeHead.rect.y < tileSize ? 600 - tileSize : snakeHead.rect.y - tileSize,
                'd' : () => snakeHead.rect.y = snakeHead.rect.y > 600 - (tileSize * 2) ? 0 : snakeHead.rect.y + tileSize,
            }
            boundsCheck[direction]();    
            updateSnakePieceGraphics(snakeHead, this);

            if(growSnake) {
                addSnakePiece(prevX,prevY, this);
                growSnake = false;
            } else {
                for(let i = 0; i < snakeBody.length; i++) {
                    let tempX = snakeBody[i].rect.x;
                    let tempY = snakeBody[i].rect.y;
                    snakeBody[i].rect.x = prevX;
                    snakeBody[i].rect.y = prevY;
                    prevX = tempX;
                    prevY = tempY;
                    updateSnakePieceGraphics(snakeBody[i], this);
                }
            }

            const {selfC, appleC} = collisionCheck();

            if(appleC) {
                removeApple();
                setApple(this);
                growSnake = true;
            } else if(selfC) {
                gameStart(this);
            }

            elapsedTime = 0.0;
            
        }
        
    }

    function gameStart(game) {

        direction = 'r';

        if(snakeHead != undefined) {
            snakeHead.graphics.destroy();
        }

        for(bodyPart of snakeBody) {
            bodyPart.graphics.destroy();
        }
        snakeBody.length = 0;

        if(apple != undefined)
            apple.graphics.destroy();

        setSnakeHead(250,200, game);
        addSnakePiece(250,200, game);
        addSnakePiece(225,200, game);
        setApple(game);
    }

    function setSnakeHead(x,y, game) {
        var rect = new Phaser.Geom.Rectangle(x, y, tileSize, tileSize);
        var graphics = game.add.graphics({ fillStyle: { color: 0xff00ff } });
        graphics.fillRectShape(rect);
        var color = 0xff00ff;
        snakeHead = {rect, graphics, color}
    }

    function addSnakePiece(x,y, game) {
        var rect = new Phaser.Geom.Rectangle(x, y, tileSize, tileSize);
        var graphics = game.add.graphics({ fillStyle: { color: 0x0000ff } });
        var color = 0x0000ff;
        graphics.fillRectShape(rect);
        let head = {rect, graphics, color}
        snakeBody.unshift(head);
    }

    function updateSnakePieceGraphics(piece, game) {
        let ngraphics = game.add.graphics({ fillStyle: { color:  piece.color} });
        piece.graphics.destroy();
        ngraphics.fillRectShape(piece.rect);
        piece.graphics = ngraphics;
    }

    function setApple(game) {

        let colliding = false;
        let getters;
        let circle;

        do {

            let x = Math.floor(Math.random() * (800 - tileSize + 1)) + tileSize;
            let y = Math.floor(Math.random() * (600 - tileSize + 1)) + tileSize;

            console.log(x,y);
            x = Math.floor(x / tileSize) * tileSize - (tileSize / 2);
            y = Math.floor(y / tileSize) * tileSize - (tileSize / 2);
            console.log(x,y);

            circle = new Phaser.Geom.Circle(x, y, tileSize / 2);
            
            for(let i = 1; i < snakeBody.length && !colliding; i++)
                colliding = Phaser.Geom.Rectangle.Overlaps(circle, snakeBody[i].rect);

            if(!colliding)
                colliding = Phaser.Geom.Rectangle.Overlaps(circle, snakeHead.rect);

        } while (colliding);

        graphics = game.add.graphics({ fillStyle: { color: 0xff0000 } });
        graphics.fillCircleShape(circle);
        apple = {circle, graphics}

    }

    function removeApple() {
        apple.graphics.destroy();
    }

    function collisionCheck() {

        let selfC = false;
        for(let i = 0; i < snakeBody.length && !selfC; i++)
            selfC = Phaser.Geom.Rectangle.Overlaps(snakeHead.rect, snakeBody[i].rect);

        let appleC = Phaser.Geom.Rectangle.Overlaps(snakeHead.rect, apple.circle);

        return {selfC, appleC};

    }

    </script>

</body>
</html>