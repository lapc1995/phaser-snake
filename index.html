<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
</head>
<body>

    <script>
    const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 200 }
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        },
    };

    const game = new Phaser.Game(config);

    const tileSize = 25;

    let snakeHead;
    const snakeBody = [];
    let apple;

    let elapsedTime = 0.0;
    let direction = 'r';

    let growSnake = false;
    let growType = undefined;

    function preload () {

        this.load.image('robot_head_blue', 'assets/sprites/robot_head_blue.png');
        this.load.image('robot_head_green', 'assets/sprites/robot_head_green.png');
        this.load.image('robot_head_yellow', 'assets/sprites/robot_head_yellow.png');
        this.load.image('robot_head_red', 'assets/sprites/robot_head_red.png');

        this.load.image('robot_blue', 'assets/sprites/robot_blue.png');
        this.load.image('robot_green', 'assets/sprites/robot_green.png');
        this.load.image('robot_yellow', 'assets/sprites/robot_yellow.png');
        this.load.image('robot_red', 'assets/sprites/robot_red.png');

        this.load.image('tile_grass_1', 'assets/sprites/tileGrass1.png');
        this.load.image('tile_grass_2', 'assets/sprites/tileGrass2.png');

    }

    function create () {
        gameStart(this);
    }

    function update (time, delta) {

        const cursors = this.input.keyboard.createCursorKeys();
        if (cursors.left.isDown && direction != 'r' && direction != 'l') {
            direction = 'l';
        }else if (cursors.right.isDown && direction != 'r' && direction != 'l') {
            direction = 'r';
        }
        else if (cursors.up.isDown && direction != 'u' && direction != 'd') {
            direction = 'u';
        }
        else if (cursors.down.isDown && direction != 'u' && direction != 'd') {
            direction = 'd';
        }

        snakeHead.direction = direction;

        elapsedTime += delta;

        if(elapsedTime > 60) {

            let prevX = snakeHead.rect.x; 
            let prevY = snakeHead.rect.y;
            let prevDirection = snakeHead.direction;

            const boundsCheck = {
                'r' : () => snakeHead.rect.x = snakeHead.rect.x > 800 - (tileSize * 2) ? 0 : snakeHead.rect.x + tileSize,
                'l' : () => snakeHead.rect.x = snakeHead.rect.x < tileSize ? 800 - tileSize : snakeHead.rect.x - tileSize,
                'u' : () => snakeHead.rect.y = snakeHead.rect.y < tileSize ? 600 - tileSize : snakeHead.rect.y - tileSize,
                'd' : () => snakeHead.rect.y = snakeHead.rect.y > 600 - (tileSize * 2) ? 0 : snakeHead.rect.y + tileSize,
            }
            boundsCheck[direction]();    
            updateSnakePieceGraphics(snakeHead, this);

            for(let i = 0; i < snakeBody.length; i++) {
                let tempX = snakeBody[i].rect.x;
                let tempY = snakeBody[i].rect.y;
                let tempDirection = snakeBody[i].direction;
                snakeBody[i].rect.x = prevX;
                snakeBody[i].rect.y = prevY;
                snakeBody[i].direction = prevDirection;
                prevX = tempX;
                prevY = tempY;
                prevDirection = tempDirection;
                updateSnakePieceGraphics(snakeBody[i], this);
            }

            if(growSnake) {
                addSnakePiece(prevX,prevY, direction, this, growType);
                growSnake = false;
                growType = undefined;
            } 

            const {selfC, appleC} = collisionCheck();

            if(appleC) {
                growType = apple.spriteType;
                removeApple();
                setApple(this);
                growSnake = true;
            } else if(selfC) {
                gameStart(this);
            }

            elapsedTime = 0.0;
            
        }
        
    }

    function gameStart(game) {

        renderBackground(game); 

        direction = 'r';

        if(snakeHead != undefined) {
            snakeHead.sprite.destroy();
        }

        for(bodyPart of snakeBody) {
            bodyPart.sprite.destroy();
        }
        snakeBody.length = 0;

        if(apple != undefined)
            apple.sprite.destroy();

        setSnakeHead(250,200, game);
        setApple(game);
    }

    function setSnakeHead(x,y, game) {
        var rect = new Phaser.Geom.Rectangle(x, y, tileSize, tileSize);
        let spriteType = Phaser.Math.RND.pick(['robot_head_blue', 'robot_head_green', 'robot_head_red', 'robot_head_yellow']);
        var sprite = game.add.image(x+(tileSize/2), y+(tileSize/2),spriteType);
        sprite.setScale(0.2)
        var direction = 'r';
        snakeHead = {rect, sprite, direction}
    }

    function addSnakePiece(x,y, direction, game, type = 'robot_blue') {
        var rect = new Phaser.Geom.Rectangle(x, y, tileSize, tileSize);
        var sprite = game.add.image(x+(tileSize/2), y+(tileSize/2), type).setScale(0.2);
        let piece = {rect, sprite, direction};
        snakeBody.push(piece);
    }

    function updateSnakePieceGraphics(piece, game) {

        piece.sprite.x = piece.rect.x + (tileSize/2);
        piece.sprite.y = piece.rect.y + (tileSize/2);

        const directionToRadians = {
            'r' : () => 0,
            'l' : () => Math.PI,
            'u' : () => 1.5 * Math.PI,
            'd' : () => Math.PI / 2
        }

        piece.sprite.rotation = directionToRadians[piece.direction](); 
        
    }

    function setApple(game) {

        let colliding;
        let circle;

        let x;
        let y;

        do {

            x = Math.floor(Math.random() * (800 - tileSize + 1)) + tileSize;
            y = Math.floor(Math.random() * (600 - tileSize + 1)) + tileSize;

            x = Math.floor(x / tileSize) * tileSize - (tileSize / 2);
            y = Math.floor(y / tileSize) * tileSize - (tileSize / 2);
            console.log(x,y);

            circle = new Phaser.Geom.Circle(x, y, tileSize / 2);

            colliding = Phaser.Geom.Rectangle.Overlaps(circle, snakeHead.rect);
            
            for(let i = 0; i < snakeBody.length && !colliding; i++)
                colliding = Phaser.Geom.Rectangle.Overlaps(circle, snakeBody[i].rect);

        } while (colliding);

        let spriteType = Phaser.Math.RND.pick(['robot_blue', 'robot_green', 'robot_red', 'robot_yellow']);

        var sprite = game.add.image(x, y, spriteType).setScale(0.2);

        sprite.rotation = Phaser.Math.RND.pick([0, Math.PI, 1.5 * Math.PI, Math.PI / 2]);

        apple = {circle, sprite, spriteType}

    }

    function removeApple() {
        apple.sprite.destroy();
    }

    function collisionCheck() {

        let selfC = false;
        for(let i = 0; i < snakeBody.length && !selfC; i++)
            selfC = Phaser.Geom.Rectangle.Overlaps(snakeHead.rect, snakeBody[i].rect);

        let appleC = Phaser.Geom.Rectangle.Overlaps(snakeHead.rect, apple.circle);

        return {selfC, appleC};

    }

    function renderBackground(game) {

        for(let i = 0; i < game.sys.game.canvas.height / tileSize; i++) {
            for(let j = 0; j < game.sys.game.canvas.width / tileSize; j++) {
                let config8 = {
                    key:  Math.random() >= 0.5 ? 'tile_grass_1': 'tile_grass_2',
                    x: j * tileSize,
                    y: i * tileSize,
                    width: tileSize,
                    height: tileSize,
                    flipX: Math.random() >= 0.5,
                    flipY: Math.random() >= 0.5
                };
                game.make.sprite(config8);
            }
        }

    }

    </script>

</body>
</html>